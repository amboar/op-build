From 36a0a2bb23a2633b4197ddd1347a6ec27c3df801 Mon Sep 17 00:00:00 2001
From: Andrew Jeffery <andrew@aj.id.au>
Date: Mon, 24 Sep 2018 23:10:33 +0930
Subject: [PATCH v3 09/11] astbmc: Use LPC probe calls to determine SIO
 presence

Avoid the probabilistic approach and use a deterministic one instead.
The probe calls use a slow, synchronous method to capture the the state
of the target device, so it is used sparingly (only on first access).

Signed-off-by: Andrew Jeffery <andrew@aj.id.au>
---
 hw/ast-bmc/ast-io.c | 30 ++++++++++--------------------
 1 file changed, 10 insertions(+), 20 deletions(-)

diff --git a/hw/ast-bmc/ast-io.c b/hw/ast-bmc/ast-io.c
index 7f8c2dafa5ef..e05348487fd4 100644
--- a/hw/ast-bmc/ast-io.c
+++ b/hw/ast-bmc/ast-io.c
@@ -323,36 +323,26 @@ static void ast_setup_sio_irq_polarity(void)
 
 static bool ast_sio_is_enabled(void)
 {
-	bool enabled;
+	int64_t rc;
 
-	lpc_outb(0xa5, 0x2e);
-	lpc_outb(0xa5, 0x2e);
+	/* Begin the unlock sequence with a probe to establish presence */
+	rc = lpc_probe_write(OPAL_LPC_IO, 0x2e, 0xa5, 1);
+	if (rc)
+		return false;
 
-	/* Heuristic attempt to confirm SIO is enabled.
-	 *
-	 * Do two tests of 1 byte, giving a false positive probability of
-	 * 1/65536. Read tests on disabled SIO tended to return 0x60.
-	 */
-	bmc_sio_outb(0x2, 0x07);
-	enabled = bmc_sio_inb(0x07) == 2;
-	if (enabled) {
-		bmc_sio_outb(0xd, 0x07);
-		enabled = bmc_sio_inb(0x07) == 0xd;
-	}
+	/* Complete the unlock sequence if the device is present */
+	lpc_outb(0xa5, 0x2e);
 
-	if (enabled)
-		lpc_outb(0xaa, 0x2e);
+	/* Re-lock to return to a known state */
+	lpc_outb(0xaa, 0x2e);
 
-	return enabled;
+	return true;
 }
 
 bool ast_sio_init(void)
 {
 	bool enabled = ast_sio_is_enabled();
 
-	prlog(PR_NOTICE, "PLAT: SuperIO is %s\n",
-	      enabled ? "available" : "unavailable!");
-
 	/* Configure all AIO interrupts to level low */
 	if (enabled)
 		ast_setup_sio_irq_polarity();
-- 
2.17.1

